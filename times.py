import datetime
from collections import namedtuple
from utils import *

### Time preference related functions ###

#TODO think if I should store both ends of the interval or just the beginning
#TODO think if I need to modify the content of these
TimeInterval = namedtuple('TimeInterval', ['start', 'end', 'satisfaction'])

#time preferences for one day (date)
PreferencesDay = namedtuple('PreferencesDay', ['date', 'intervals'])

#type(day) = datetime.date
#get an ordered list of time intervals that overlap with 'day'
def get_member_time_preferences_for_day(member_id, day):
    sql = "SELECT GREATEST(time_beginning, :day),\
           LEAST(time_end, :day + '1 day'::interval), satisfaction FROM \
           MemberTimeSelections WHERE member_id=:member_id \
           AND time_end > :day AND time_beginning < (:day + '1 day'::interval)\
           ORDER BY time_beginning"

    result = db.session.execute(sql, {'member_id': member_id,
                                      'day':day}).fetchall()

    #print("result: ", result)
    if result is None:
        return []

    return [TimeInterval(*x) for x in result]

#TODO think if this should return a named tuple
def get_time_preferences(member_id, first_date, last_date):
    result = []
    i = first_date
    while i <= last_date:
        tmp = get_member_time_preferences_for_day(member_id, i)
        result.append(PreferencesDay(i,  tmp))
        i += datetime.timedelta(days=1)

    return result

def get_user_time_preferences(user_id, poll_id):
    first_date, last_date = get_poll_date_range(poll_id)
    member_id = get_user_poll_member_id(user_id, poll_id)
    print("userid, memberid", user_id, member_id, poll_id)
    print(first_date, last_date)
    return get_time_preferences(member_id, first_date, last_date)

def get_resource_time_preferences(user_id, poll_id):
    pass

#Modifies existing time preference intervals so that truncates
#partially overlapping intervals and removes completely overlapping intervals
#and then adds the new inteval
#start and end are datetime.datetime
def add_member_time_preference(member_id, start, end, satisfaction):
    #fetch a segment inside which the new segment is
    #ooooooo
    # nnnn
    sql = "SELECT * FROM MemberTimeSelections WHERE member_id=:member_id \
           AND time_beginning < :start AND time_end > :end"

    result = db.session.execute(sql, {'member_id': member_id, 'start': start,
                             'end': end}).fetchone()

    if result is not None:
        sql = "DELETE FROM MemberTimeSelections WHERE member_id=:member_id \
               AND time_beginning < :start AND time_end > :end"
        db.session.execute(sql, {'member_id': member_id, 'start': start,
                                 'end': end})

        sql = "INSERT INTO MemberTimeSelections \
               (member_id, time_beginning, time_end, satisfaction) VALUES \
               (:member_id, :time_beginning, :time_end, :satisfaction)"
        db.session.execute(sql, {'member_id': result[0],
                                 'time_beginning': result[1],
                                 'time_end': start,
                                 'satisfaction': result[3]})

        db.session.execute(sql, {'member_id': result[0],
                                 'time_beginning': end,
                                 'time_end': result[2],
                                 'satisfaction': result[3]})


    #right side of the old segment is inside the new segment
    # ooooo
    #  nnnnnnn
    sql = "UPDATE MemberTimeSelections SET \
           time_end = :start \
           WHERE member_id=:member_id AND time_end >= :start \
           AND time_end <= :end"
    db.session.execute(sql, {'member_id': member_id, 'start': start,
                              'end': end})
    #left side of the old segment is inside the new segment
    #     ooooo
    #  nnnnnnn
    sql = "UPDATE MemberTimeSelections SET \
           time_beginning = :end \
           WHERE member_id=:member_id AND time_beginning >= :start \
           AND time_beginning <= :end"
    db.session.execute(sql, {'member_id': member_id, 'start': start,
                              'end': end})

    #remove non-positive length segments (in case these were generated by the
    #previous operations)
    sql = "DELETE FROM MemberTimeSelections WHERE member_id=:member_id \
           AND time_end<=time_beginning"
    db.session.execute(sql, {'member_id': member_id})

    #add new segment
    sql = "INSERT INTO MemberTimeSelections \
           (member_id, time_beginning, time_end, satisfaction) \
           VALUES \
           (:member_id, :start, :end, :satisfaction)"

    db.session.execute(sql, {'member_id': member_id, 'start': start,
                             'end': end, 'satisfaction': satisfaction})

    #TODO think if this function should commit.
    db.session.commit()

def process_new_time_preference(poll_id, start_time, end_time, date,
                                satisfaction):
    start_time = datetime.time.fromisoformat(start_time)
    end_time = datetime.time.fromisoformat(end_time)
    date = datetime.date.fromisoformat(date)

    user_id = session.get('user_id')
    start_datetime = datetime.datetime.combine(date, start_time)
    end_datetime = datetime.datetime.combine(date, end_time)

    if start_datetime >= end_datetime:
        print('start_datetime > end_datetime')
        return False

    if satisfaction not in ['0', '1', '2']:
        print("invalid satisfaction value")
        return False
    member_id = get_user_poll_member_id(user_id, poll_id)
    print("start_datetime, end_datetime: ", start_datetime, end_datetime)
    add_member_time_preference(member_id, start_datetime, end_datetime,
                               satisfaction)

    return True

